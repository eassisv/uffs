#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct _nodo{
  int chave, altdir, altesq, nivel, altura;
  struct _nodo *esq, *dir, *pai;
}Nodo;

typedef struct _arvore{
  Nodo *raiz;
}Arvore;

Arvore* inicializa_arvore();
int insere_elemento(Arvore *tree, int valor);
void lista_elementos(Arvore *tree);

int main(void){
  int opcao, valor;
  Arvore *tree = inicializa_arvore();

  do{
    printf("Digite a opção\n1. Inserir elemento.:\n2. Listar valores da árvore.:\n0. Sair.:\n");
    scanf("%d", &opcao);
    switch(opcao){
    case 1:
      scanf("%d", &valor);
      insere_elemento(tree, valor);
      break;
    case 2:
      lista_elementos(tree);
      break;
    case 0:
      break;
    default:
      printf("Opcão inválida\n\n");
    }
  }while(opcao);

  return 0;
}

Arvore* inicializa_arvore(){
  Arvore *novo = (Arvore *) malloc(sizeof(Arvore));
  novo->raiz = NULL;
  return novo;
}

int max(int a, int b){
  return (a > b)? a : b;
}

void atualiza_nivel(Nodo *nodo){
  if(!nodo) return;
  nodo->nivel = (nodo->pai == nodo)? 0 : nodo->pai->nivel + 1;
  atualiza_nivel(nodo->dir);
  atualiza_nivel(nodo->esq);
}

Nodo* atualiza_altura(Nodo *nodo){
  if(nodo->dir) nodo->altdir = nodo->dir->altura + 1;
  else nodo->altdir = 0;
  if(nodo->esq) nodo->altesq = nodo->esq->altura + 1;
  else nodo->altesq = 0;
  nodo->altura = max(nodo->altesq, nodo->altdir);
  //Se encontrei um nodo desbalanceado eu retorno o seu endereço para rebalancear
  if(abs(nodo->altesq - nodo->altdir) > 1) return nodo;
  
  if(nodo->pai != nodo)	return atualiza_altura(nodo->pai);
  return NULL;
}

Nodo* busca_pai(Nodo *pai, Nodo *novo){
  if(pai->chave < novo->chave){
    if(pai->dir)
      return busca_pai(pai->dir, novo);
    pai->dir = novo;
    return pai;				
  }
  if(pai->chave > novo->chave){
    if(pai->esq)
      return busca_pai(pai->esq, novo);
    pai->esq = novo;
    return pai;				
  }
  //Retorna nulo caso o elemente seja repetido
  return NULL;
}

void rotacao_simples_esquerda(Nodo *subtree, Arvore *tree){
  Nodo *aux = subtree->dir, *pai = subtree->pai;
  if(pai == subtree) tree->raiz = pai = subtree->dir;
  else{
    if(pai->chave < aux->chave) pai->dir = aux;
    else pai->esq = aux;
  }
  subtree->pai = aux;
  subtree->dir = aux->esq;
  if(aux->esq) aux->esq->pai = subtree;
  aux->esq = subtree;
  aux->pai = pai;
  atualiza_altura(subtree);
  atualiza_nivel(aux);
}

void rotacao_simples_direita(Nodo *subtree, Arvore *tree){
  Nodo *aux = subtree->esq, *pai = subtree->pai;
  if(pai == subtree) tree->raiz = pai = subtree->esq;
  else{
    if(pai->chave < aux->chave) pai->dir = aux;
    else pai->esq = aux;
  }
  subtree->pai = aux;
  subtree->esq = aux->dir;
  if(aux->dir) aux->dir->pai = subtree;
  aux->dir = subtree;
  aux->pai = pai;
  atualiza_altura(subtree);
  atualiza_nivel(aux);
}

void balanceia_arvore(Nodo *subtree, Arvore *tree){
  if(!subtree) return;
  Nodo* aux;
  if(subtree->altesq - subtree->altdir < 0){
    aux = subtree->dir;
    //Verifica se precisa de rotação dupla (joelho)
    if(aux->altesq - aux->altdir > 0) rotacao_simples_direita(aux, tree);
    rotacao_simples_esquerda(subtree, tree);
  }else{
    aux = subtree->esq;
    //Verifica se precisa de rotação dupla (joelho)
    if(aux->altesq - aux->altdir < 0) rotacao_simples_esquerda(aux, tree);
    rotacao_simples_direita(subtree, tree);
  }
}


int insere_elemento(Arvore *tree, int chave){
  Nodo *novo = (Nodo*) malloc(sizeof(Nodo)); 

  novo->chave = chave;
  novo->esq = novo->dir = NULL;	
  if(tree->raiz){
    novo->pai = busca_pai(tree->raiz, novo);
    //Se não encontrei um pai é porque o elemente é repetido
    if(!novo->pai){
      free(novo);
      return 0;
    }
    atualiza_nivel(novo);
    balanceia_arvore(atualiza_altura(novo), tree);
    return 1;
  }
  novo->pai = novo;
  atualiza_nivel(novo);
  atualiza_altura(novo);
  tree->raiz = novo;
  return 1;
}

void pre_fixa(Nodo *nodo){	
  printf("Chave: %3d, Nivel: %3d, Altura(e/d): %d/%d, Pai: %3d\n", nodo->chave, nodo->nivel, nodo->altesq, nodo->altdir, nodo->pai->chave);
  if(nodo->esq)
    pre_fixa(nodo->esq);
  if(nodo->dir)
    pre_fixa(nodo->dir);
}

void lista_elementos(Arvore *tree){
  if(tree->raiz)
    pre_fixa(tree->raiz);
  printf("\n");
}
